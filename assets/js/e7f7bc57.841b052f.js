"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[5816],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,g=d["".concat(l,".").concat(u)]||d[u]||m[u]||i;return n?r.createElement(g,o(o({ref:t},p),{},{components:n})):r.createElement(g,o({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5297:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={sidebar_label:"Program testing",sidebar_position:4},l=void 0,c={unversionedId:"developing-contracts/testing",id:"developing-contracts/testing",title:"testing",description:"Smart contract testing",source:"@site/docs/developing-contracts/testing.md",sourceDirName:"developing-contracts",slug:"/developing-contracts/testing",permalink:"/developing-contracts/testing",editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/developing-contracts/testing.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"Program testing",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Message Format",permalink:"/developing-contracts/messaging"},next:{title:"Upload Program",permalink:"/developing-contracts/deploy"}},p=[{value:"Smart contract testing",id:"smart-contract-testing",children:[{value:"Basics",id:"basics",children:[],level:3},{value:"Building smart contract in test mode",id:"building-smart-contract-in-test-mode",children:[],level:3},{value:"Import <code>gtest</code> lib",id:"import-gtest-lib",children:[],level:3},{value:"Possible issues",id:"possible-issues",children:[],level:3}],level:2},{value:"<code>gtest</code> capabilities",id:"gtest-capabilities",children:[],level:2}],m={toc:p};function d(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"smart-contract-testing"},"Smart contract testing"),(0,i.kt)("p",null,"Gear lib ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/gear-tech/gear/tree/master/gtest"},(0,i.kt)("inlineCode",{parentName:"a"},"gtest"))," is the recommended option for the smart contracts logic testing. This article describes how to test smart contracts using ",(0,i.kt)("inlineCode",{parentName:"p"},"gtest"),"."),(0,i.kt)("h3",{id:"basics"},"Basics"),(0,i.kt)("p",null,"Gear uses the standard for Rust programs testing mechanism - test build mode from ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo"),"."),(0,i.kt)("p",null,"In accordance to basic concepts and testing methods described in ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch11-00-testing.html"},"Rustbook"),", tests can be organized in two main categories: ",(0,i.kt)("strong",{parentName:"p"},"unit tests")," and ",(0,i.kt)("strong",{parentName:"p"},"integration tests"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"unit tests")," enable testing of each unit of code in isolation from the rest of the code. It helps to quickly find where the code works as expected and where not. The unit tests should be placed in the ",(0,i.kt)("inlineCode",{parentName:"p"},"src")," directory in each file with the code that they test."),(0,i.kt)("p",null,"Even when units of code work correctly, it is important to test if several parts of the library work together correctly as well. For ",(0,i.kt)("strong",{parentName:"p"},"integration tests"),", a separate tests directory is required at the top level of your project directory, next to ",(0,i.kt)("inlineCode",{parentName:"p"},"src"),". You can make as many test files in this directory as you need, Cargo will compile each of the files as an individual crate."),(0,i.kt)("h3",{id:"building-smart-contract-in-test-mode"},"Building smart contract in test mode"),(0,i.kt)("p",null,"First of all, make sure you have a compiled ",(0,i.kt)("inlineCode",{parentName:"p"},"WASM")," file of the program you want to test. You can refer to ",(0,i.kt)("a",{parentName:"p",href:"/getting-started-in-5-minutes"},"Getting started")," for additional details."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Usually the following mandatory parameters must be used for regular compilation of Gear smart contracts:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'RUSTFLAGS="-C link-args=--import-memory"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--target=wasm32-unknown-unknown")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nightly")," \u0441ompiler")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'cd ~/gear/contracts/first-gear-app/\nRUSTFLAGS="-C link-args=--import-memory" cargo +nightly build --release --target=wasm32-unknown-unknown\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"For test running  they should ",(0,i.kt)("strong",{parentName:"p"},"not be used"),", instead the following conditions are ",(0,i.kt)("strong",{parentName:"p"},"required"),":"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"--target")," is not ",(0,i.kt)("inlineCode",{parentName:"li"},"wasm32-unknown-unknown"),". It is recommended to build for the architecture of your device (you don't need to specify any flags at all)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nightly")," compiler - required if your contract uses unstable Rust features - the compiler will ask you to enable ",(0,i.kt)("inlineCode",{parentName:"li"},"nightly")," if necessary. Only if you are writing the tests as unit/integration tests, rather than providing a separate library containing only the tests.")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"cargo test\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If you use ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo")," config files, then keep in mind that ",(0,i.kt)("inlineCode",{parentName:"p"},"[build]")," parameters are applied both to ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo build")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo test")," ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/cargo/issues/6784"},"Github Issue"),". For example - "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-toml"},'# .cargo/config.toml\n[build]\ntarget = "wasm32-unknown-unknown"\n\n[target.wasm32-unknown-unknown]\nrustflags = ["-C", "link-args=--import-memory"]\n')),(0,i.kt)("p",{parentName:"li"},"In this case, you have to choose the most convenient option for you:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"(Recommended) Remove build target ",(0,i.kt)("inlineCode",{parentName:"p"},"target=wasm32-unknown-unknown")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"config.toml"),", which means that you have to"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Build the contract with: ",(0,i.kt)("inlineCode",{parentName:"li"},"cargo +nightly build --target wasm32-unknown-unknown")),(0,i.kt)("li",{parentName:"ul"},"Run test as: ",(0,i.kt)("inlineCode",{parentName:"li"},"cargo test")," (optionally: ",(0,i.kt)("inlineCode",{parentName:"li"},"cargo +nightly test"),")"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Keep target in the configuration file, in this case:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Build the contract with: ",(0,i.kt)("inlineCode",{parentName:"li"},"cargo +nightly build")),(0,i.kt)("li",{parentName:"ul"},"Run test as: ",(0,i.kt)("inlineCode",{parentName:"li"},"cargo test --target any_not_wasm32_unknown_unknown_target")))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Every supported by Rust target is available from this command:\n",(0,i.kt)("inlineCode",{parentName:"p"},"rustc --print target-list")))),(0,i.kt)("p",null,"How to find out your system target is described ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/52996949/how-can-i-find-the-current-rust-compilers-default-llvm-target-triple?rq=1"},"here"),"."),(0,i.kt)("p",null,"So the most universal way to run test will be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"cargo test --target \"$(rustc -vV | sed -n 's|host: ||p')\"\n")),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},(0,i.kt)("inlineCode",{parentName:"p"},"sed")," tool isn\u2019t installed by default for Windows"))),(0,i.kt)("p",null,"For details on cargo configuration files, see ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/cargo/reference/config.html"},"Cargobook"),"."),(0,i.kt)("h3",{id:"import-gtest-lib"},"Import ",(0,i.kt)("inlineCode",{parentName:"h3"},"gtest")," lib"),(0,i.kt)("p",null,"In order to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"gtest")," library, it must be imported into your ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file in the ",(0,i.kt)("inlineCode",{parentName:"p"},"[dev-dependencies]")," block in order to fetch and compile it for tests only"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'[package]\nname = "first-gear-app"\nversion = "0.1.0"\nauthors = ["Your Name"]\nedition = "2021"\nlicense = "GPL-3.0"\n\n[lib]\ncrate-type = ["cdylib"]\n\n[dependencies]\ngstd = { git = "https://github.com/gear-tech/gear.git", features = ["debug"] }\n\n[dev-dependencies]\ngtest = { git = "https://github.com/gear-tech/gear.git" }\n\n[profile.release]\nlto = true\nopt-level = \'s\'\n')),(0,i.kt)("h3",{id:"possible-issues"},"Possible issues"),(0,i.kt)("p",null,"When writing tests as integration tests, it is not possible to import public structures from within the program itself, because gear contracts must have ",(0,i.kt)("inlineCode",{parentName:"p"},'crate-type=["cdylib"]')," struct and nothing can be imported from them."),(0,i.kt)("p",null,"Solution options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"(Recommended) Create a sub-crate library with IO structures and import it into ",(0,i.kt)("inlineCode",{parentName:"li"},"Cargo.toml"),". In this case, structures will be available everywhere."),(0,i.kt)("li",{parentName:"ul"},"Redefine the same structures in the test file (copy-paste), because with codec they will produce the same bytes.")),(0,i.kt)("h2",{id:"gtest-capabilities"},(0,i.kt)("inlineCode",{parentName:"h2"},"gtest")," capabilities"),(0,i.kt)("p",null,"The example provided for ",(0,i.kt)("a",{parentName:"p",href:"/developing-contracts/examples/ping"},"PING-PONG"),"  program."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use gtest::{Log, Program, System};\n\n#[test]\nfn basics() {\n    // Initialization of the common environment for running smart contacts.\n    //\n    // This emulates node\'s and chain behavior.\n    //\n    // By default, sets:\n    // - current block equals 0\n    // - current timestamp equals UNIX timestamp of your system.\n    // - minimal message id equal 0x010000..\n    // - minimal program id equal 0x010000..\n    let sys = System::new();\n\n    // You may control time in the system by spending blocks.\n    //\n    // It adds the amount of blocks passed as argument to the current block of the system.\n    // Same for the timestamp. Note, that for now 1 block in Gear network is 1 sec duration.\n    sys.spend_blocks(150);\n\n    // Initialization of styled `env_logger` to print logs (only from `gwasm` by default) into stdout.\n    //\n    // To specify printed logs, set the env variable `RUST_LOG`:\n    // `RUST_LOG="target_1=logging_level,target_2=logging_level" cargo test`\n    //\n    // Gear smart contracts use `gwasm` target with `debug` logging level\n    sys.init_logger();\n\n    // Initialization of program structure from file.\n    //\n    // Takes as arguments reference to the related `System` and the path to wasm binary relatively \n    // the root of the crate where the test was written.\n    //\n    // Sets free program id from the related `System` to this program. For this case it equals 0x010000..\n    // Next program initialized without id specification will have id 0x020000.. and so on.\n    let ping_pong = Program::from_file(\n        &sys,\n        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",\n    );\n\n    // We can check the id of the program by calling `id()` function.\n    //\n    // It returns `ProgramId` type value.\n    let ping_pong_id = ping_pong.id();\n\n    // There is also a `from_file_with_id` constructor to manually specify the id of the program.\n    //\n    // Every place in this lib, where you need to specify some ids,\n    // it requires generic type `ID`, which implements `Into<ProgramIdWrapper>`.\n    //\n    // `ProgramIdWrapper` may be built from:\n    // - u64;\n    // - [u8; 32];\n    // - String;\n    // - &str;\n    // - ProgramId (from `gear_core` one\'s, not from `gstd`).\n    //\n    // String implementation means the input as hex (with or without "0x")\n\n    // Numeric\n    let _ = Program::from_file_with_id(\n        &sys,\n        105,\n        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",\n    );\n\n    // Hex with "0x"\n    let _ = Program::from_file_with_id(\n        &sys,\n        "0xe659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df4e",\n        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",\n    );\n\n    // Hex without "0x"\n    let _ = Program::from_file_with_id(\n        &sys,\n        "e659a7a1628cdd93febc04a4e0646ea20e9f5f0ce097d9a05290d4a9e054df5e",\n        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",\n    );\n\n    // Array [u8; 32] (e.g. filled with 5)\n    let _ = Program::from_file_with_id(\n        &sys,\n        [5; 32],\n        "./target/wasm32-unknown-unknown/release/demo_ping.wasm",\n    );\n\n    // If you initialize program not in this scope, in cycle, in other conditions,\n    // where you didn\'t save the structure, you may get the object from the system by id.\n    let _ = sys.get_program(105);\n\n    // To send message to the program need to call one of two program\'s functions:\n    // `send()` or `send_bytes()`.\n    //\n    // Both of the methods require sender id as the first argument and the payload as second.\n    //\n    // The difference between them is pretty simple and similar to `gstd` functions\n    // `msg::send()` and `msg::send_bytes()`.\n    //\n    // The first one requires payload to be CODEC Encodable, while the second requires payload\n    // implement `AsRef<[u8]>`, that means to be able to represent as bytes.\n    //\n    // `send()` uses `send_bytes()` under the hood with bytes from payload.encode().\n    //\n    // First message to the initialized program structure is always the init message.\n    let res = ping_pong.send_bytes(100001, "INIT MESSAGE");\n\n    // Any sending functions in the lib returns `RunResult` structure.\n    //\n    // It contains the final result of the processing message and others,\n    // which were created during the execution.\n    //\n    // It has 4 main functions.\n\n    // Returns the reference to the Vec produced to users messages.\n    // You may assert them as you wish, iterating through them.\n    assert!(res.log().is_empty());\n\n    // Returns bool which shows that there was panic during the execution\n    // of the main message.\n    assert!(!res.main_failed());\n\n    // Returns bool which shows that there was panic during the execution\n    // of the created messages during the main execution.\n    //\n    // Equals false if no others were called.\n    assert!(!res.others_failed());\n\n    // Returns bool which shows that logs contains a given log.\n    //\n    // Syntax sugar around `res.log().iter().any(|v| v == arg)`.\n    assert!(!res.contains(&Log::builder()));\n\n    // To build a log for assertion you need to use `Log` structure with it\'s builders.\n    // All fields here are optional.\n    // Assertion with Logs from core are made on the Some(..) fields\n    // You will run into panic if you try to set the already specified field.\n    //\n    // Constructor for success log.\n    let _ = Log::builder();\n\n    // Constructor for error reply log.\n    //\n    // Note that error reply never contains payload.\n    // And it\'s exit code equals 1, instead of 0 for success replies.\n    let _ = Log::error_builder();\n\n    // Let\u2019s send a new message after the program has been initialized.\n    let res = ping_pong.send_bytes(100001, "PING");\n\n    // Other fields are set optionally by `dest()`, `source()`, `payload()`, `payload_bytes()`.\n    //\n    // The logic for `payload()` and `payload_bytes()` is the same as for `send()` and `send_bytes()`.\n    // First requires an encodable struct. The second requires bytes.\n    let log = Log::builder()\n        .source(ping_pong_id)\n        .dest(100001)\n        .payload_bytes("PONG");\n\n    assert!(res.contains(&log));\n\n    let wrong_log = Log::builder().source(100001);\n\n    assert!(!res.contains(&wrong_log));\n\n    // Log also has `From` implementations from (ID, T) and from (ID, ID, T),\n    // where ID: Into<ProgramIdWrapper>, T: AsRef<[u8]>\n    let x = Log::builder().dest(5).payload_bytes("A");\n    let x_from: Log = (5, "A").into();\n\n    assert_eq!(x, x_from);\n\n    let y = Log::builder().dest(5).source(15).payload_bytes("A");\n    let y_from: Log = (15, 5, "A").into();\n\n    assert_eq!(y, y_from);\n\n    assert!(!res.contains(&(ping_pong_id, ping_pong_id, "PONG")));\n    assert!(res.contains(&(1, 100001, "PONG")));\n}\n')))}d.isMDXComponent=!0}}]);