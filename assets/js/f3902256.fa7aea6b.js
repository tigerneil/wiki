"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[1263],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2851:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_label:"DAO",sidebar_position:4},l="Decentralized autonomous organization",p={unversionedId:"developing-contracts/examples/DAO",id:"developing-contracts/examples/DAO",title:"Decentralized autonomous organization",description:"The smart-contract is available on GitHub//github.com/gear-tech/apps/tree/master/dao",source:"@site/docs/developing-contracts/examples/DAO.md",sourceDirName:"developing-contracts/examples",slug:"/developing-contracts/examples/DAO",permalink:"/developing-contracts/examples/DAO",editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/developing-contracts/examples/DAO.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"DAO",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"ERC-20",permalink:"/developing-contracts/examples/erc20"},next:{title:"Gear Feeds",permalink:"/developing-contracts/examples/feeds"}},u=[{value:"Source files",id:"source-files",children:[],level:2},{value:"Structs",id:"structs",children:[],level:2},{value:"DAO functions",id:"dao-functions",children:[],level:2}],c={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"decentralized-autonomous-organization"},"Decentralized autonomous organization"),(0,o.kt)("p",null,"The smart-contract is available on GitHub: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gear-tech/apps/tree/master/dao"},"https://github.com/gear-tech/apps/tree/master/dao")),(0,o.kt)("h2",{id:"source-files"},"Source files"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"erc20_functions.rs")," - contains functions of the ERC20 contract. DAO contract interacts ERC20 contract through functions ",(0,o.kt)("inlineCode",{parentName:"li"},"transfer_tokens")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"balance"),":")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub async fn transfer_tokens(\n        &mut self,\n        token_id: &ActorId, /// - the ERC-20 contracts address\n        from: &ActorId, /// - the sender address\n        to: &ActorId, /// - the recipient address\n        amount: u128, /// - the amount of tokens\n)\n")),(0,o.kt)("p",null,"This function sends a message (the action is defined in the enum ",(0,o.kt)("inlineCode",{parentName:"p"},"TokenAction"),") and gets a reply (the reply is defined in the enum ",(0,o.kt)("inlineCode",{parentName:"p"},"TokenEvent"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    let transfer_response: TokenEvent = msg::send_and_wait_for_reply(\n        *token_id, /// - the ERC-20 contracts address,\n        TokenAction::Transfer(transfer_data), /// - action in ERC20-contract\n        exec::gas_available() - GAS_RESERVE,\n        0,\n    )\n")),(0,o.kt)("p",null,"The function balance is defined in a similar way:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub async fn balance(\n        &mut self,\n        token_id: &ActorId, /// - the ERC-20 contracts address\n        account: &ActorId, /// - the account address\n)\n")),(0,o.kt)("p",null,"and sends a message:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let balance_response: TokenEvent = msg::send_and_wait_for_reply(\n        *token_id, /// - the ERC-20 contracts address,\n        TokenAction::BalanceOf(H256::from_slice(account.as_ref())) /// - action in ERC20-contract\n        exec::gas_available() - GAS_RESERVE,\n        0,\n    )\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"payloads.rs")," - contains structs that the contract receives and sends in the reply.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"lib.rs")," - defines the contract logic."))),(0,o.kt)("h2",{id:"structs"},"Structs"),(0,o.kt)("p",null,"The contract has the following structs:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"struct Dao {\n    admin: ActorId,\n    approved_token_program_id: ActorId,\n    period_duration: u64,\n    voting_period_length: u64,\n    grace_period_length: u64,\n    dilution_bound: u128,\n    abort_window: u64, \n    total_shares: u128,\n    members: BTreeMap<ActorId, Member>,\n    member_by_delegate_key: BTreeMap<ActorId, ActorId>,\n    proposal_id: u128,\n    proposals: BTreeMap<u128, Proposal>,\n    approved_list: Vec<ActorId>,\n}\n")),(0,o.kt)("p",null,"where:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"admin")," - the only member that is initially in DAO. He has 1 share that allows him to submit new proposal and therefore add new members."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"approved_token_program_id")," - the reference to the token contract (ERC20) that users use as pledge to get the share in the DAO."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"period_duration")," - the smallest unit time interval for the DAO, in ms."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"voting_period_length")," - voting time interval. Number of intervals for voting time = period duration * voting_period_length."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"grace_period_length")," - after the voting period the DAO members are given a period of time in which they can leave the DAO(ragequit) without being diluted and ultimately affected by the proposal\u2019s acceptance into the DAO."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"dilution_bound")," - the dilution bound protects members from excessive dilution in case of a mass ragequit. It is designed to mitigate an issue where a proposal is passed, then many users rage quit from the DAO. The proposal will be automatically rejected if the total amount of shares becomes dilutionBound times less than it was before."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"abort_window")," - the time interval during which the applicant can cancel the proposal with funds refunded (that starts immediately when the proposal is submitted)."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"total_shares")," - total shares across all members. Initially it is zero."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"members")," - members of the DAO."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"member_by_delegate_key")," - mapping the key responsible for submitting proposals and the member address."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"proposal_id")," - the index of the last proposal."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"proposals")," - all proposals (the proposal queue)."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"approved_list")," - list of actors that are approved for joining the DAO."),(0,o.kt)("p",null,"Parameters ",(0,o.kt)("inlineCode",{parentName:"p"},"admin"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"approved_token_program_id"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"period_duration"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"grace_period_length"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"dilution_bound"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"abort_window")," are set when initializing a contract. The contract is initialized in the function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\npub unsafe extern "C" fn init() {\n    ...\n}\n')),(0,o.kt)("p",null,"with the following struct: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"struct InitConfig {\n    admin: H256,\n    approved_token_program_id: H256,\n    guild_bank_id: H256,    \n    period_duration: u64,\n    voting_period_length: u64,\n    grace_period_length: u64,\n    dilution_bound: u128,\n    abort_window: u64,\n}\n")),(0,o.kt)("p",null,"The proposal struct:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"}," pub struct Proposal {\n    pub proposer: ActorId, /// - the member who submitted the proposal\n    pub applicant: ActorId, /// - the applicant who wishes to become a member \n    pub shares_requested: u128, /// - the amount of shares the applicant is requesting\n    pub yes_votes: u128, /// - the total number of YES votes for that proposal\n    pub no_votes: u128, /// - the total number of NO votes for that proposal\n    pub quorum: u128, /// - a certain threshold of YES votes in order for the proposal to pass\n    pub is_membership_proposal: bool, /// - true if it is a membership proposal, false if it is a funding proposal\n    pub processed: bool, /// - true if the proposal has already been processed\n    pub did_pass: bool, /// - true if the proposal has passed\n    pub canceled: bool, /// - true if the proposal has been canceled\n    pub aborted: bool, /// - true if the proposal has been aborted\n    pub token_tribute: u128, /// - the number of tokens offered for shares\n    pub details: String, /// - proposal details\n    pub starting_period: u64, /// - the start of the voting period\n    pub max_total_shares_at_yes_vote: u128, /// - the number of total shares that were detected at yes votes\n    pub votes_by_member: BTreeMap<H256, Vote>, /// - the votes on that proposal by each member\n}\n")),(0,o.kt)("p",null,"The member struct:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Member {\n    pub delegate_key: ActorId, /// - the key responsible for submitting proposals and voting ( by default it is equal to member address)\n    pub shares: u128, /// - the shares of that member\n    pub highest_index_yes_vote: u128, /// - the index of the highest proposal on which the members voted YES (that value is checked when user is going to leave the DAO)\n}\n")),(0,o.kt)("p",null,"The actions that the contract receives outside are defined in enum ",(0,o.kt)("inlineCode",{parentName:"p"},"Actions"),". The contract's replies are defined in the enum ",(0,o.kt)("inlineCode",{parentName:"p"},"Events"),"."),(0,o.kt)("h2",{id:"dao-functions"},"DAO functions"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Adds actors to approved list. The added actors can deposit their tokens to DAO and a DAO member can submit a proposal of joining them to DAO members.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn add_to_approved_list(\n        &mut self,\n        member: &ActorId,\n)\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The proposal of joining the DAO. The proposal can be submitted only by the existing members.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn submit_membership_proposal(\n        &mut self,\n        applicant: &ActorId,\n        token_tribute: u128,\n        shares_requested: u128,\n        quorum: u128,\n        details: String,\n    )\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The funding proposal. The 'applicant' is an actor that will be funded.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn submit_funding_proposal(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0&mut self,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0applicant: &ActorId,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0amount: u128,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0quorum: u128,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0details: String,\n\xa0\xa0\xa0\xa0)\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The member or the delegate address of the member submit his vote (YES or NO) on the proposal.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn submit_vote(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0&mut self,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0proposal_id: u128,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0vote: Vote,\n\xa0\xa0\xa0\xa0)\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The right of the applicant to abort the proposal. It can be used in case of the applicant disagreed with the requested shares or the details the proposer indicated by the proposer.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn abort(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0&mut self,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0proposal_id: u128\n\xa0\xa0\xa0\xa0)\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The right of the proposer to cancel the proposal after the end of the voting period if there are no YES votes.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn cancel_proposal(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0&mut self,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0proposal_id: u128,\n\xa0\xa0\xa0\xa0)\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The right for members to withdraw their capital during the grace period. It can be used when the members don\u2019t agree with the result of the proposal and the acceptance of that proposal can affect their shares. The member can ragequit only if he has voted NO on that proposal.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn ragequit(\n    &mut self,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0amount: u128,\n\xa0\xa0\xa0\xa0)\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The proposal processing after the proposal competes during the grace period. If the proposal is accepted, the tribute tokens are deposited into the contract and new shares are minted and issued to the applicant. If the proposal is rejected, the tribute tokens are returned to the applicant.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn process_proposal(\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0&mut self,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0proposal_id: u128\n\xa0\xa0\xa0\xa0)\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"These functions are called in ",(0,o.kt)("inlineCode",{parentName:"li"},"async fn main()")," through enum ",(0,o.kt)("inlineCode",{parentName:"li"},"Actions"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'    #[gstd::async_main] \n    async fn main() {\n        let action: Action = msg::load().expect("Could not load Action");\n        match action {\n        Action::AddToWhiteList(input) => {\n            DAO.add_to_whitelist(&ActorId::new(input.to_fixed_bytes()))\n        }\n        Action::SubmitMembershipProposal(input) => {\n            let applicant = ActorId::new(input.applicant.to_fixed_bytes());\n            DAO.submit_membership_proposal(\n                &applicant,\n                input.token_tribute,\n                input.shares_requested,\n                input.quorum,\n                input.details,\n            )\n            .await;\n        }\n        Action::SubmitFundingProposal(input) => {\n            let applicant = ActorId::new(input.applicant.to_fixed_bytes());\n            DAO.submit_funding_proposal(&applicant, input.amount, input.quorum, input.details)\n                .await;\n        }\n                        ...\n            }\n    }\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"It is also important to have the ability to read the contract state off-chain. It is defined in the ",(0,o.kt)("inlineCode",{parentName:"li"},"fn meta_state()"),".  The contract receives a request to read the certain data (the possible requests are defined in struct ",(0,o.kt)("inlineCode",{parentName:"li"},"State"),") and sends replies. The contracts replies about its state are defined in the enum ",(0,o.kt)("inlineCode",{parentName:"li"},"StateReply"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'pub unsafe extern "C" fn meta_state() -> *mut [i32; 2] {\n    let state: State = msg::load().expect("failed to decode input argument");\n    let encoded = match state {\n        State::IsMember(input) => {\n    StateReply::IsMember(DAO.is_member(&ActorId::new(input.to_fixed_bytes()))).encode()\n        }\n       ...\n    };\n    let result = gstd::macros::util::to_wasm_ptr(&(encoded[..]));\n    core::mem::forget(encoded);\n    result\n}\n')))}d.isMDXComponent=!0}}]);