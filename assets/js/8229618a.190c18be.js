"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[4328],{3905:function(e,t,r){r.d(t,{Zo:function(){return m},kt:function(){return d}});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=a.createContext({}),l=function(e){var t=a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},m=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),p=l(r),d=n,h=p["".concat(c,".").concat(d)]||p[d]||u[d]||o;return r?a.createElement(h,s(s({ref:t},m),{},{components:r})):a.createElement(h,s({ref:t},m))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var l=2;l<o;l++)s[l]=r[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}p.displayName="MDXCreateElement"},2351:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return m},default:function(){return p}});var a=r(7462),n=r(3366),o=(r(7294),r(3905)),s=["components"],i={sidebar_label:"Actor Model",sidebar_position:4},c="Actor Model",l={unversionedId:"gear/actor-model",id:"gear/actor-model",title:"Actor Model",description:"In concurrent computing systems, \u201cmessage-passing communication\u201d means that programs communicate by exchanging messages. This has its advantages over \u201cshared memory communication\u201d as message passing is easier to understand than shared memory concurrency as it\u2019s more robust and has better performance characteristics.",source:"@site/docs/gear/actor-model.md",sourceDirName:"gear",slug:"/gear/actor-model",permalink:"/gear/actor-model",editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/gear/actor-model.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"Actor Model",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"State Transition",permalink:"/gear/gear-state/state-transition"},next:{title:"Memory Parallelism",permalink:"/gear/memory-parallelism"}},m=[{value:"Actor",id:"actor",children:[],level:2},{value:"Async/await support",id:"asyncawait-support",children:[],level:2}],u={toc:m};function p(e){var t=e.components,r=(0,n.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"actor-model"},"Actor Model"),(0,o.kt)("p",null,"In concurrent computing systems, \u201cmessage-passing communication\u201d means that programs communicate by exchanging messages. This has its advantages over \u201cshared memory communication\u201d as message passing is easier to understand than shared memory concurrency as it\u2019s more robust and has better performance characteristics."),(0,o.kt)("p",null,"For inter-process communications, Gear uses the Actor model approach. The principle of the Actor model approach is that programs never share any state and just exchange messages between each other."),(0,o.kt)("p",null,"With the Actor model, systems consist of simultaneously functioning objects that communicate with each other exclusively by messaging. While an ordinary Actor model does not guarantee message ordering, Gear provides some additional guarantees that the order of messages between two particular programs is preserved."),(0,o.kt)("p",null,"The Actor model guarantees high scalability and high fault tolerance. "),(0,o.kt)("h2",{id:"actor"},"Actor"),(0,o.kt)("p",null,"An Actor in the Actor model is an atomic computational unit that can send and receive messages. With Gear, an Actor is a program (smart contract) or a user that sends messages to a program. Every Actor has an internal private state and a mailbox. Communication is asynchronous, messages are popped out from the mailbox and allocated to message processing streams where they\u2019re then processed in cycles."),(0,o.kt)("p",null,"When an actor receives and processes a message, the response can be the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Send a message to another actor")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Create another actor")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Change its own internal state"))),(0,o.kt)("p",null,"Actors are independent, they never share any state and just exchange messages with each other."),(0,o.kt)("p",null,"Using the Actor model approach provides a way to implement Actor-based concurrency inside smart contract logic. It can utilize various language constructs for asynchronous programming (Futures and async-await in Rust)."),(0,o.kt)("h2",{id:"asyncawait-support"},"Async/await support"),(0,o.kt)("p",null,"Unlike classes, Actors allow only one task to access their mutable state at a time, which makes it safe for code in multiple tasks to interact with the same instance of an actor."),(0,o.kt)("p",null,"Asynchronous functions significantly streamline concurrency management, but they do not handle the possibility of deadlocks or state corruption. To avoid deadlocks or state corruption, async functions should avoid calling functions that may block their thread. To achieve it, they use an await expression."),(0,o.kt)("p",null,"Currently, the lack of normal support of async/await patterns in the typical smart contracts code brings a lot of problems for smart contract developers. Actually, achieving better control in a smart contract program flow is actually more or less possible by adding handmade functions (in Solidity smart contracts). But the problem with many functions in a contract is that one can easily get confused - which function can be called at which stage in the contract's lifetime."),(0,o.kt)("p",null,"Gear natively provides arbitrary async/await syntax for any programs. It greatly simplifies development and testing and reduces the likelihood of errors in smart contract development. Gear API also allows synchronous messages by simply not using await expression if the logic of the program requires it."))}p.isMDXComponent=!0}}]);